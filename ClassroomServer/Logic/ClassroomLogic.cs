namespace ClassroomServer.Logic
{
    using ClassLibrary;
    using Microsoft.Extensions.Logging;
    using NLog;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading;

    /// <summary>
    /// Represents the state of the classroom, including the session state, student count, and threshold.
    /// </summary>
    public class ClassroomState
    {
        /// <summary>
        /// Lock for thread-safe access.
        /// </summary>
        public readonly object AccessLock = new object();

        /// <summary>
        /// Indicates if the class is currently in session.
        /// </summary>
        public bool ClassInSession = false;

        /// <summary>
        /// Current number of students in the class.
        /// </summary>
        public int StudentCount = 0;

        /// <summary>
        /// Threshold of students required to start the class.
        /// </summary>
        public readonly int StartThreshold = 3;

        /// <summary>
        /// Determines if the votes are sufficient to start or end the class session.
        /// </summary>
        /// <param name="votesStart">Dictionary of teacher votes to start the session.</param>
        /// <returns>True if sufficient votes to start or end, false otherwise.</returns>
        public bool AreVotesStartSufficient(Dictionary<int, bool> votesStart)
        {
            if (votesStart.Count <= 1) return false;

            int trueCount = votesStart.Values.Count(v => v);
            double ratio = (double)trueCount / votesStart.Count;
            double threshold = 0.5;
            return ratio > threshold;
        }
    }

    /// <summary>
    /// Handles the main logic for the classroom, including managing student counts, session status, and voting by teachers.
    /// </summary>
    public class ClassroomLogic
    {
        /// <summary>
        /// Last unique identifier for teachers or other entities.
        /// </summary>
        public int LastUniqueId;

        /// <summary>
        /// Logger instance for logging actions and events.
        /// </summary>
        private Logger mLog = LogManager.GetCurrentClassLogger();

        /// <summary>
        /// Collection of teacher votes to start the class.
        /// </summary>
        private Dictionary<int, bool> VotesStart = new Dictionary<int, bool>();

        /// <summary>
        /// Collection of teacher votes to end the class.
        /// </summary>
        private Dictionary<int, bool> VotesEnd = new Dictionary<int, bool>();

        /// <summary>
        /// Instance of ClassroomState to store session state and student information.
        /// </summary>
        private ClassroomState mState = new ClassroomState();

        /// <summary>
        /// Tracks the number of students generated by doors.
        /// </summary>
        private int generatedstudent { get; set; }

        /// <summary>
        /// Increments the number of students based on incoming data from the door.
        /// </summary>
        /// <param name="studentCount">The count of students generated by the door.</param>
        public void studnetnsnumber(int studentCount)
        {
            lock (mState.AccessLock)
            {
                generatedstudent += studentCount;
                mLog.Info($"[Door] Incremented student count by {studentCount}. Total students: {generatedstudent}");
            }
        }

        /// <summary>
        /// Determines if there are enough students to initiate the voting process for starting a class.
        /// </summary>
        /// <returns>True if there are enough students, false otherwise.</returns>
        public bool canvotingstart()
        {
            lock (mState.AccessLock)
            {
                bool canVote = generatedstudent >= mState.StartThreshold && !mState.ClassInSession;
                mLog.Info($"[Voting Check] Students generated: {generatedstudent}, Threshold: {mState.StartThreshold}, Can start voting: {canVote}");
                return canVote;
            }
        }

        /// <summary>
        /// Retrieves a unique identifier to assign to teachers or other entities.
        /// </summary>
        /// <returns>A unique identifier integer.</returns>
        public int GetUniqueId()
        {
            lock (mState.AccessLock)
            {
                LastUniqueId += 1;
                mLog.Info($"[Unique ID] Assigned new unique ID: {LastUniqueId}");
                return LastUniqueId;
            }
        }

        /// <summary>
        /// Checks the current session state of the class.
        /// </summary>
        /// <returns>True if class is in session, false otherwise.</returns>
        public bool IsClassInSession()
        {
            lock (mState.AccessLock)
            {
                mLog.Info($"[Class Session Status] Class in session: {mState.ClassInSession}");
                return mState.ClassInSession;
            }
        }

        /// <summary>
        /// Records a teacher's vote to start the class.
        /// </summary>
        /// <param name="teacher">The teacher casting the vote.</param>
        /// <returns>True if the vote leads to starting the class, false otherwise.</returns>
        public bool VoteToStartClass(Teacher teacher)
        {
            lock (mState.AccessLock)
            {
                if (mState.ClassInSession)
                {
                    mLog.Info($"[Vote Start] Teacher {teacher.TeacherId} attempted to vote, but class is already in session.");
                    return false;
                }

                VotesStart[teacher.TeacherId] = teacher.HasVotedToStart;
                mLog.Info($"[Vote Start] Teacher {teacher.TeacherId} voted to start: {teacher.HasVotedToStart}");

                if (VotesStart.Count == LastUniqueId && mState.AreVotesStartSufficient(VotesStart))
                {
                    StartClass();
                    mLog.Info("[Vote Start] Sufficient votes received to start the class.");
                    return true;
                }
                mLog.Info("[Vote Start] Insufficient votes to start the class.");
                return false;
            }
        }

        /// <summary>
        /// Records a teacher's vote to end the class.
        /// </summary>
        /// <param name="teacher">The teacher casting the vote.</param>
        /// <returns>True if the vote leads to ending the class, false otherwise.</returns>
        public bool VoteToEndClass(Teacher teacher)
        {
            lock (mState.AccessLock)
            {
                VotesEnd[teacher.TeacherId] = teacher.HasVotedToEnd;
                mLog.Info($"[Vote End] Teacher {teacher.TeacherId} voted to end: {teacher.HasVotedToEnd}");

                if (VotesEnd.Count == LastUniqueId && mState.AreVotesStartSufficient(VotesEnd))
                {
                    EndClass();
                    mLog.Info("[Vote End] Sufficient votes received to end the class.");
                    return true;
                }
                mLog.Info("[Vote End] Insufficient votes to end the class.");
                return false;
            }
        }

        /// <summary>
        /// Initiates the class session, clears previous votes, and logs the action.
        /// </summary>
        private void StartClass()
        {
            lock (mState.AccessLock)
            {
                mState.ClassInSession = true;
                VotesStart.Clear();  // Reset VotesStart for the next session
                mLog.Info("[Class Start] Class has started. All previous votes have been cleared.");
            }
        }

        /// <summary>
        /// Ends the class session, clears votes, and adjusts the student count based on a randomized number of students leaving.
        /// </summary>
        private void EndClass()
        {
            lock (mState.AccessLock)
            {
                mState.ClassInSession = false;
                VotesEnd.Clear(); // Reset VotesEnd for the next session

                // Calculate random number of students leaving
                int studentsLeaving = new Random().Next(1, mState.StudentCount + 1);
                mState.StudentCount -= studentsLeaving;
                mState.StudentCount = Math.Max(0, mState.StudentCount);

                mLog.Info($"[Class End] Class has ended. {studentsLeaving} students left. Current student count: {mState.StudentCount}");
            }
        }
    }
}
